
;-----------
;  ENNEMIES
;-----------


to setup-ennemies
  create-ennemies nb-ennemies
  ; on récupere tous les patch qui ne sont pas des obstacles donc ponts et vert
  let good-patches n-of nb-ennemies patches with [pzcor = solAlt and not obstacle? and not any? other turtles-here and (pxcor > 25 or pycor > 25)]
  ask ennemies [    set pv e-life
    set shape "car"
    ; on leur donne la meme fct de vitesse que le convoi avec des parametres differents
    set speed 0.05 * e-speed * simu-speed
    set carburant 100
    ; on pose l'agent sur un patch non obstacle
    let good-patch one-of good-patches
    ;on place l'ennemi sur le patch
    move-to good-patch
    ; on supprime le patch de la liste des possibles
    set good-patches good-patches with [self != good-patch]
    set zcor solAlt
    ;setxyz random-xcor random-ycor mapAlt;( min-pycor + 1 ) random-zcor
    set color red
    set freq-tir 0 ; initialisée à 0 pour pouvoir tirer la premiere balle
    set maxdir 10 * simu-speed
  ]
end


;;; Pour gérer le déplacement des ennemies
to go-ennemies
  ask ennemies [
    if (pv > 0)[
      ;;
      let nearest-convoi detect-convoi e-vision ;min-one-of convois in-radius-nowrap e-vision [distance-nowrap myself]
      ;let nearest min-one-of convois with [zcor = solAlt] in-radius-nowrap e-vision [distance-nowrap myself]
      let nearest-drone min-one-of drones with [zcor > solAlt and zcor < max-pzcor] in-radius-nowrap e-vision [distance-nowrap myself]
      
      ;let nearest detect-convoi-or-drone e-vision
      ifelse (nearest-convoi != nobody or nearest-drone != nobody)[
        set color blue
        ifelse (nearest-drone != nobody)
        [ attack-convoi-or-drone nearest-drone ]
        [ attack-convoi-or-drone nearest-convoi ]
      ]
      [
        set color red
        ;set to-follow nobody
        random-walk]
      ;right random 90
      ;;; Si l'agent n'a plus de carburant il marche
      ;ifelse carburant > 0
      ;[ forward ( random speed + 1 )]
      ;[ forward ((random speed + 1 )/ 2) ]
    ]
  ]
end

to attack-convoi-or-drone [nearest]
  set heading towards nearest
  ifelse (distance nearest <= e-dist-tir)[
    set color yellow
    ifelse (freq-tir = 0) [
      face nearest
      hatch-bullets 1 [
        set num 1
        set speed 0.2 * simu-speed
        set energy (e-dist-tir * 20)
        set color red ; TODO calcul a détermine
      ]
      set freq-tir e-frequence-tir * e-dist-tir / simu-speed
      set pitch 0
    ]
    [
      set freq-tir (freq-tir - 1)]
  ]
  
  [
    if not detect-obstacle [fd speed]
  ] ; ils vont a l'encontre du convoi qu'ils on vu
end

;;; INUTILISEE
;;; Renvoie True si un obstacle se trouve sur le chemin de moi vers pdir
; False sinon
to-report detect-obstacle-path [ pdir]
  let cpt 1
  while [cpt <= pdir] [
    if ([montagne?] of patch-ahead cpt = true and [mur-map?] of patch-ahead cpt = true)
    [report true]
    set cpt cpt + 1 
  ]
  report false
end

;;; Renvoie le plus proche convoi dans un rayon de distance, sur un angle de angle
; Renvoie nobody sinon
; en parcourant tous les patches alentours par diametre incrémenté de 1
to-report detect-convoi0 [angle dist]
  let cpt 1
  let cases-impossibles [] ; liste de valeur impossibles
                           ;let cases-parcourues [] ; liste de tuple (listes de 2 elts) des cases deja verifiees
  while [cpt <= dist]
  [
    ; on récupere les extremités du carre à analyser
    let xmin pxcor - cpt
    let xmax pxcor + cpt
    let ymin pycor - cpt
    let ymax pycor + cpt
    
    let xcpt xmin
    ; pour chaque x entre xmax et xmin
    while [xcpt <= xmax]
    [
      let ycpt ymin
      ; pour chaque y entre ymin et ymax
      while [ycpt <= ymax]
      [
        ; si la case fait partie des bordures
        ; alors on la considère
        if (xcpt = xmin or xcpt = xmax or ycpt = ymin or ycpt = ymax)
        [
          let patch-au-loin patch xcpt ycpt solAlt
          ; on verifie s'il s'agit d'un obstacle
          ifelse ([obstacle?] of patch-au-loin = true)
          [ set cases-impossibles lput (list xcpt ycpt) cases-impossibles ] ; on enregistre l'obstacle
          [; on verifie si un turtle convoi se trouve sur la case
            let convois-on-patch convois-on patch-au-loin
            if (any? convois-on-patch)
            [report one-of convois-on-patch]
          ]
        ]
        set ycpt ycpt + 1
      ]
      set xcpt xcpt + 1
    ]
    set cpt cpt + 1
  ]
  report nobody
end


;;; USED
to-report detect-convoi [dist]
  ;; tant qu'on n'a pas inspecté tous les patches dans la distance attendue
  ;;;; on inspecte tous les patches sur une distance pour un angle donné
  let cpt 1
  let angle 360 ; on verifie toujours tout autour
  let cases-visitees []
  ;; on enregistre tous les angles a eliminer parce qu'un obstacle y a été vu plus tot (liste)
  let angles-impossibles []
  ;; on avance en augmentant le rayon de verification
  while [cpt <= dist] [
    ; on teste pour angle/2 à gauche (donc -angle/2) et angle/2 à gauche
    let ss-cpt (0 - (angle / 2))
    ;; on verifie dans l'angle de 5 en 5 (estimation arbitraire)
    while [ss-cpt <= angle / 2] [
      ; si l'angle a été scellé
      if (not member? ss-cpt angles-impossibles)
      [
        let patch-au-loin patch-at-heading-and-distance ss-cpt cpt
        ifelse (member? patch-au-loin cases-visitees)
        [set cases-visitees lput patch-au-loin cases-visitees]
        [
          ;; on verifie les obstacles sur cette case pour choisir de sceller cet angle
          ifelse ([obstacle?] of patch-au-loin = true)
          [
            ;print "angle scellé"
            set angles-impossibles lput ss-cpt angles-impossibles]
          [
            let convois-on-patch convois-on patch-au-loin
            if (any? convois-on-patch) [
              ;;; on verifie si le chemin ne comporte pas d'obstacles
              ;  set heading ss-cpt
              ;  ifelse (not detect-obstacle-path cpt)[
              report one-of convois-on-patch]
            ; [set heading -1 * ss-cpt]]
          ]
        ]
      ]
      set ss-cpt ss-cpt + 7 ; increment de 7 choisi arbitrairement
    ]
    set cpt cpt + 1
  ]
  report nobody
end

;;; Renvoie le plus proche drone ou convoi dans un rayon de distance, sur 360° en 3D
; donnant la priorité au drone
; Renvoie nobody sinon
to-report detect-convoi-or-drone0 [dist]
  ;; tant qu'on n'a pas inspecté tous les patches dans la distance attendue avec l'angle attendu
  ;;;; on inspecte tous les patches sur une distance pour un angle donné
  let cpt 1
  let zcpt solAlt
  let angle 360 ; on verifie toujours tout autour
                ;; on enregistre tous les angles a eliminer parce qu'un obstacle y a été vu plus tot (liste)
  let angles-impossibles []
  let cases-visitees []
  ;; on avance en augmentant le rayon de verification
  while [cpt <= dist] [
    ; on teste pour angle/2 à gauche (donc -angle/2) et angle/2 à gauche
    let ss-cpt (0 - (angle / 2))
    ;; on verifie dans l'angle de 5 en 5 (estimation arbitraire)
    while [ss-cpt <= angle / 2] [
      ; si l'angle a été scellé
      if (not member? ss-cpt angles-impossibles)
      [
        let patch-au-loin patch-at-heading-and-distance ss-cpt cpt
        ifelse (member? patch-au-loin cases-visitees)
        [set cases-visitees lput patch-au-loin cases-visitees]
        [
          ;; on verifie les obstacles sur cette case pour choisir de sceller cet angle
          ifelse ([obstacle?] of patch-au-loin = true)
          [
            ;print "angle scellé"
            set angles-impossibles lput ss-cpt angles-impossibles]
          [
            let convois-on-patch convois-on patch-au-loin
            if (any? convois-on-patch) [
              ;;; on verifie si le chemin ne comporte pas d'obstacles
              ;  set heading ss-cpt
              ;  ifelse (not detect-obstacle-path cpt)[
              report one-of convois-on-patch]
            ; [set heading -1 * ss-cpt]]
          ]
        ]
      ]
      set ss-cpt ss-cpt + 7 ; increment de 7 choisi arbitrairement
    ]
    set cpt cpt + 1
  ]
  report nobody
end

to-report detect-convoi-or-drone [dist]
  let cpt 1
  let cases-impossibles [] ; liste de valeur impossibles
                           ;let cases-parcourues [] ; liste de tuple (listes de 2 elts) des cases deja verifiees
  while [cpt <= dist]
  [
    ; on récupere les extremités du carre à analyser
    let xmin pxcor - cpt
    let xmax pxcor + cpt
    let ymin pycor - cpt
    let ymax pycor + cpt
    let zmin solAlt
    let zmax max-pzcor
    
    let zcpt zmin
    while [zcpt <= zmax]
    [
      let xcpt xmin
      ; pour chaque x entre xmax et xmin
      while [xcpt <= xmax]
      [
        let ycpt ymin
        ; pour chaque y entre ymin et ymax
        while [ycpt <= ymax]
        [
          ; si la case fait partie des bordures
          ; alors on la considère
          if (xcpt = xmin or xcpt = xmax or ycpt = ymin or ycpt = ymax)
          [
            let patch-au-loin patch xcpt ycpt zcpt
            ; on verifie s'il s'agit d'un obstacle
            ifelse ([obstacle?] of patch-au-loin = true)
            [ set cases-impossibles lput (list xcpt ycpt) cases-impossibles ] ; on enregistre l'obstacle
            [; on verifie si un turtle convoi se trouve sur la case
              ifelse (zcpt = solAlt)
              [
              let convois-on-patch convois-on patch-au-loin
              if (any? convois-on-patch)
              [report one-of convois-on-patch]
              ]
              [
              let drones-on-patch drones-on patch-au-loin
              if (any? drones-on-patch)
              [report one-of drones-on-patch]
                
              ]
            ]
          ]
          set ycpt ycpt + 1
        ]
        set xcpt xcpt + 1
      ]
      set zcpt zcpt + 1

    ]
    set cpt cpt + 1
  ]
  report nobody
end

to-report a-voir[dist]
  ;; tant qu'on n'a pas inspecté tous les patches dans la distance attendues
  ;;;; on inspecte tous les patches sur une distance
  let cpt 1 ; jusqu'a dist
            ;; on enregistre tous les angles a eliminer parce qu'un obstacle y a été vu plus tot (liste)
  let angles-impossibles []
  ;; on avance en augmentant le rayon de verification
  while [cpt <= dist] [
    ; on teste pour angle/2 à gauche (donc -angle/2) et angle/2 à gauche
    let angle-z-cpt 0 ; entre 0 et 180
                      ;; on verifie dans le pitch de 5 en 5 (estimation arbitraire)
                      ; on regarde l'axe z
    while [angle-z-cpt <= 180] [
      ; on change l'orientation en z
      set pitch angle-z-cpt
      ; on teste pour angle/2 à gauche (donc -angle/2) et angle/2 à gauche
      let angle-head-cpt -90 ; entre -180 et 180
                             ;; on verifie dans l'angle de 5 en 5 (estimation arbitraire)
      while [angle-head-cpt <= 90] [
        ; si l'angle a été scellé
        if (not member? angle-head-cpt angles-impossibles)
        [
          let patch-au-loin patch-at-heading-and-distance angle-head-cpt cpt
          ;; on verifie les obstacles sur cette case pour choisir de sceller cet angle
          ifelse ([obstacle?] of patch-au-loin = true)
          [
            ;print "angle scellé"
            set angles-impossibles lput angle-head-cpt angles-impossibles]
          [
            let drones-on-patch drones-on patch-au-loin
            if (any? drones-on-patch) [
              report one-of drones-on-patch]
            if (pitch = 0)[
              let convois-on-patch convois-on patch-au-loin
              if (any? convois-on-patch) [
                ;;; on verifie si le chemin ne comporte pas d'obstacles
                ;  set heading ss-cpt
                ;  ifelse (not detect-obstacle-path cpt)[
                set pitch 0
                report one-of convois-on-patch]
              ; [set heading -1 * ss-cpt]]
            ]
          ]
        ]
        set angle-head-cpt angle-head-cpt + 7 ; increment de 7 choisi arbitrairement
      ]
      set angle-z-cpt angle-z-cpt + 10 ; increment de 10 choisi arbitrairement
    ]
    set cpt cpt + 1
  ]
  report nobody
end

to-report analyse-turtles-patches [dist]
  ; on recupere les coordonnées du patch sur lequel est l'agent
  let xcoord pxcor
  let ycoord pycor
  ; on récupère les patches dans un rayon de dist
  ; TODO ici uniquement les convois
  let patches-in-dist patches with [pxcor < xcoord + dist and pxcor > xcoord - dist and pycor < ycoord + dist and pycor > ycoord - dist and pycor = solAlt]
  let convois-in-dist convois-on patches-in-dist
  ifelse (any? convois-in-dist)
  [report min-one-of convois-in-dist [distance myself] ]
  [report nobody]
end